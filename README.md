# Introduction
This is a final project for the SI507 Intermediate Programming course at the University of Michigan. The program fetches top tracks from the Last.FM music charts and gets relevant information about the tracks through the Spotify API. It then stores the data into a question tree that asks users about their preferences for music and provides personal song recommendations based on their choices. Aside from that, users can also check out further information about the top tracks through the visualizations generated by the program.

# Required Packages
- Flask
- Flask-Session
- Plotly
- pandas
- requests

# Instructions
### Obtaining Spotify and Last.FM API Keys
To fetch real time data, a set of API keys from Last.FM and Spotify is required. Both of them require users to create an account in order to obtain the IDs and keys. Visit the [Last.FM](https://www.last.fm/api/authentication) and [Spotify](https://developer.spotify.com/documentation/general/guides/authorization/) Authentication pages for more detailed instructions. After obtaining the keys, paste your **Spotify Client ID**, **Spotify Client Secret**, and **Last.FM API key** in the "secrets.py" file to successfully fetch real time data from the two web APIs. To save time, a file with exported data called "Top_Track_Data.json" is included in the files to directly load data from the time when the code was written.

### Running the Main Program
Run the "final_proj.py" file and enter [http://127.0.0.1:5000/](http://127.0.0.1:5000/) in your web browser to interact with the program.

### Interactions and Data Presentations
The program provides two main services:
1. **Music recommendation**
- Fill out and submit form to get a list of 10 personal music recommendations from the top charts
- Users can also select a track from the recommended list to check out detailed information about the track, including a radar chart showing the track's audio features
- Refresh the page if you're not satisfied with the results
2. **Statistics related to the recent top 10 tracks**
- A table showing the top 10 tracks from the Last.FM charts
- A bar chart showing their popularity ranking on Spotify
- A radar chart showing the average numbers of their audio features

# Data Structure
All fetched data are stored in a tree with nodes that contain either questions or the actual data. There will be four yes/no questions that asks users about their preferences, which leads to 16 possible ways in total of grouping the data. The tree structure is as follows (the alphabets represent data):
```
tree = \
    ["Do you prefer some dance music?(Y/N)", 
        ["Do you prefer some acoustic music?(Y/N)", 
            ["Do you prefer some loud and energetic music?(Y/N)", 
                ["Do you prefer some happy and positive music?(Y/N)",
                    [a,None,None],[b,None,None]],
                ["Do you prefer some happy and positive music?(Y/N)",
                    [c,None,None],[d,None,None]]], 
            ["Do you prefer louder music? (Y/N)",
                ["Do you prefer some happy and positive music?(Y/N)",
                    [e,None,None],[f,None,None]],
                ["Do you prefer some happy and positive music?(Y/N)",
                    [g,None,None],[h,None,None]]]],
        ["Do you prefer some acoustic music?(Y/N)", 
            ["Do you prefer some loud and energetic music?(Y/N)",
                ["Do you prefer some happy and positive music?(Y/N)",
                    [i,None,None],[j,None,None]],
                ["Do you prefer some happy and positive music?(Y/N)",
                    [k,None,None],[l,None,None]]], 
            ["Do you prefer some loud and energetic music?(Y/N)",
                ["Do you prefer some happy and positive music?(Y/N)",
                    [m,None,None],[n,None,None]],
                ["Do you prefer some happy and positive music?(Y/N)",
                    [o,None,None],[p,None,None]]]]]
```
The data stored in each of the end nodes are lists of dictionaries that hold information about each track such as track name, artist, audio features, etc. The complete structure of the tree can be found from the "tree.json" file.
